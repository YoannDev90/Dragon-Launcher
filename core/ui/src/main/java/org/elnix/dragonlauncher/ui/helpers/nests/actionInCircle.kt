package org.elnix.dragonlauncher.ui.helpers.nests

import androidx.compose.runtime.mutableStateListOf
import androidx.compose.runtime.snapshots.SnapshotStateList
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.BlendMode
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.ColorFilter
import androidx.compose.ui.graphics.Outline
import androidx.compose.ui.graphics.Path
import androidx.compose.ui.graphics.drawscope.DrawScope
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.graphics.drawscope.translate
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.IntSize
import org.elnix.dragonlauncher.common.R
import org.elnix.dragonlauncher.common.points.SwipeDrawParams
import org.elnix.dragonlauncher.common.serializables.IconShape
import org.elnix.dragonlauncher.common.serializables.SwipeActionSerializable
import org.elnix.dragonlauncher.common.serializables.SwipePointSerializable
import org.elnix.dragonlauncher.common.serializables.applyColorAction
import org.elnix.dragonlauncher.common.serializables.defaultSwipePointsValues
import org.elnix.dragonlauncher.common.utils.ImageUtils
import org.elnix.dragonlauncher.common.utils.ImageUtils.loadDrawableResAsBitmap
import org.elnix.dragonlauncher.common.utils.UiCircle
import org.elnix.dragonlauncher.ui.actions.actionColor
import org.elnix.dragonlauncher.ui.components.resolveShape


fun DrawScope.actionsInCircle(
    drawParams: SwipeDrawParams,

    point: SwipePointSerializable,
    selected: Boolean,
    preventBgErasing: Boolean = false
) {
    val ctx = drawParams.ctx
    val nests = drawParams.nests
    val defaultPoint = drawParams.defaultPoint
    val pointIcons = drawParams.pointIcons
    val surfaceColorDraw = drawParams.surfaceColorDraw
    val extraColors = drawParams.extraColors
    val density = drawParams.density
    val depth = drawParams.depth
    val maxDepth = drawParams.maxDepth
    val iconShape = drawParams.iconShape
    val center = drawParams.center


    val action = point.action

    val px = center.x
    val py = center.y

    val size = (point.size ?: defaultPoint.size ?: defaultSwipePointsValues.size!!).coerceAtLeast(1)
    val innerPadding =
        point.innerPadding ?: defaultPoint.innerPadding ?: defaultSwipePointsValues.innerPadding!!

    val iconSize = size / depth
    val borderRadii = ((size / 2 + innerPadding).coerceAtLeast(0) / depth).toFloat()

    val dstOffset = IntOffset(px.toInt() - iconSize / 2, py.toInt() - iconSize / 2)
    val intSize = IntSize(iconSize, iconSize)

    val borderColor = if (selected) {
        point.borderColorSelected?.let { Color(it) }
            ?: defaultPoint.borderColorSelected?.let { Color(it) }
    } else {
        point.borderColor?.let { Color(it) } ?: defaultPoint.borderColor?.let { Color(it) }
    } ?: extraColors.circle

    val borderStroke = if (selected) {
        point.borderStrokeSelected ?: defaultPoint.borderStrokeSelected ?: 8f
    } else {
        point.borderStroke ?: defaultPoint.borderStroke ?: 4f
    }

    val borderIconShape = if (selected) {
        point.borderShapeSelected ?: defaultPoint.borderShapeSelected
    } else {
        point.borderShape ?: defaultPoint.borderShape
    } ?: IconShape.Circle


    val borderShape = borderIconShape.resolveShape()

    val backgroundColor = if (selected) {
        point.backgroundColorSelected?.let { Color(it) }
            ?: defaultPoint.backgroundColorSelected?.let { Color(it) }
    } else {
        point.backgroundColor?.let { Color(it) } ?: defaultPoint.backgroundColor?.let { Color(it) }
    } ?: if (preventBgErasing) {
        surfaceColorDraw
    } else {
        Color.Transparent
    }

    val shape = (point.customIcon?.shape ?: iconShape).resolveShape()


    if (depth <= maxDepth) {

        if (action !is SwipeActionSerializable.OpenCircleNest) {

            /* ───────────── Erases the circle in the point ───────────── */

            // if no background color provided, erases the background
            val eraseBg = backgroundColor == Color.Transparent && !preventBgErasing

            // Erases the color, instead of putting it, that lets the wallpaper pass trough
            drawCircle(
                color = Color.Transparent,
                radius = borderRadii,
                center = center,
                blendMode = BlendMode.Clear
            )

            // If requested to not erase the bg, draw it (this avoid the more tinted bg when using a half transparent bg color
            if (!eraseBg) {
                drawCircle(
                    color = backgroundColor,
                    radius = borderRadii,
                    center = center
                )
            }


            /* ───────────── Draws the border (custom shape) ───────────── */

            val iconSizeF = borderRadii * 2f


            val outline = borderShape.createOutline(
                size = Size(iconSizeF, iconSizeF),
                layoutDirection = layoutDirection,
                density = this
            )

            val path = when (outline) {
                is Outline.Rectangle -> Path().apply { addRect(outline.rect) }
                is Outline.Rounded -> Path().apply { addRoundRect(outline.roundRect) }
                is Outline.Generic -> outline.path
            }

            // Move drawing to icon position
            translate(
                left = center.x - borderRadii,
                top = center.y - borderRadii
            ) {

                if (borderStroke > 0f) {
                    if (borderColor.alpha != 0f) {

                        drawPath(
                            path = path,
                            color = borderColor,
                            style = Stroke(width = borderStroke)
                        )
                    }
                }
            }


            val icon = point.id.let { pointIcons[it] }
            val colorAction = actionColor(point.action, extraColors)



            if (icon != null) {

                val clipped = ImageUtils.clipImageToShape(
                    image = icon,
                    shape = shape,
                    sizePx = size,
                    density = density
                )

                drawImage(
                    image = clipped,
                    dstOffset = dstOffset,
                    dstSize = intSize,
                    colorFilter =
                        if (point.applyColorAction()) ColorFilter.tint(colorAction)
                        else null
                )
            }

        } else {
            nests.find { it.id == action.nestId }?.let { nest ->

                val circlesWidthIncrement = 1f / (nest.dragDistances.size - 1)

                val newCircles: SnapshotStateList<UiCircle> = mutableStateListOf()


                nest.dragDistances.filter { it.key != -1 }.forEach { (index, _) ->
                    val radius = (100f / depth) * circlesWidthIncrement * (index + 1)
                    newCircles.add(
                        UiCircle(index, radius)
                    )
                }

                circlesSettingsOverlay(
                    drawParams = drawParams.copy(
                        depth = depth + 1
                    ),

                    circles = newCircles,
                    selectedPoint = point,
                    nestId = nest.id,
                    selectedAll = selected,
                    preventBgErasing = preventBgErasing
                )
            } ?: drawImage( // <- if this is drawn there a big bug
                image = loadDrawableResAsBitmap(ctx, R.drawable.ic_action_target, 48, 48),
                dstOffset = dstOffset,
                dstSize = intSize
            )
        }
    }
}
